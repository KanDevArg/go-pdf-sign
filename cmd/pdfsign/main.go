package main

import (
	"bytes"
	"crypto"
	"crypto/sha256"
	"encoding/asn1"
	"encoding/hex"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"time"

	pdfcpu "github.com/pdfcpu/pdfcpu/pkg/api"
	pdf "github.com/pdfcpu/pdfcpu/pkg/pdfcpu"

	rfc3161 "github.com/clocklock/go-rfc3161"
	PDFCPULog "github.com/pdfcpu/pdfcpu/pkg/log"
	pdfsign "github.com/philhug/go-pdf-sign/pkg/pdf-sign"
)

func createAnnotation(xRefTable *pdf.XRefTable, value pdf.IndirectRef) (*pdf.IndirectRef, error) {

	d := pdf.Dict(map[string]pdf.Object{
		"Type":    pdf.Name("Annot"),
		"Subtype": pdf.Name("Widget"),
		"Rect":    pdf.NewIntegerArray(0, 0, 0, 0),
		"FT":      pdf.Name("Sig"),                 //assistive tech
		"T":       pdf.StringLiteral("Signature1"), //field name
		"V":       value,
		"F":       pdf.Integer(4), // Flags=
		//"P": 0, //Page
	})

	return xRefTable.IndRefForNewObject(d)
}

func doSign() error {
	if len(os.Args) != 3 {
		panic("usage: xxx test.pdf out.pdf")
	}
	fi, err := os.Open(os.Args[1])
	if err != nil {
		panic(err)
	}
	defer fi.Close()
	fo, err := os.Create(os.Args[2])
	if err != nil {
		panic(err)
	}
	defer fo.Close()
	conf := pdf.Configuration{}
	c, err := pdfcpu.ReadContext(fi, &conf)
	if err != nil {
		panic(err)
	}

	//fmt.Println(c)
	br := pdf.NewIntegerArray(10000000, 10000000, 10000000, 10000000)

	pkcs7, _ := hex.DecodeString("3082057D06092A864886F70D010702A082056E3082056A020101310F300D06096086480165030402010500300B06092A864886F70D010701A08203543082035030820238A003020102020AC140FE68A2A6FDC6820A300D06092A864886F70D01010B05003056310D300B060355040313044A757374310D300B060355040A13046E6F6E65310B3009060355040B13024D65311C301A06092A864886F70D010901160D6E6F6E65406E6F6E652E636F6D310B3009060355040613025553301E170D3230303632333037303831305A170D3235303632333037303831305A3056310D300B060355040313044A757374310D300B060355040A13046E6F6E65310B3009060355040B13024D65311C301A06092A864886F70D010901160D6E6F6E65406E6F6E652E636F6D310B300906035504061302555330820122300D06092A864886F70D01010105000382010F003082010A0282010100BE9E1D2FFCFA45AF7DA8FB5B3BC418F3E29B6B4DFC65F625669FFB7EDF9A71B9831BE75A80A5A8CB632B9E4681908E1ABB645B78931D9660C81BEFD4F3D2CD8DA4E9B2A02038E1DF85224966598C32688779B9FC008FEDD8CDFB0737225EC045890F11CE4F20351116EF369B07296FA7F3BDC8C5035B2ABAA4D1888441296CF29EC581FDFF375C2EA77EEA1AC88ACEAEDD768ECF5BDCFAA377AC28B78561B88E9253775BE76C2778646E37ACD2326CE2D47325260BAA343B2BBFF4384FB7FBFD64EF34C749EECA45EF1792D259E55AFD0C63B2FDE87AF81AB20519A5E56324E78AF94A5DA37FBA91158209851B38D1D072B0A9DE47CF0A5F603F7D11CB6101AF0203010001A320301E300F06092A864886F72F01010A04020500300B0603551D0F040403020780300D06092A864886F70D01010B050003820101000D659EC57E2C6368BCE77EF748B12F059E33059517BF2F270E3ECA8539DD58AFB8583D3079ECE3962AA1BE7BA2F7D6062E957D25DB56740C35C9858814CABD34917163910AACF02F4DA77208FEC9C5C3B5A5171AD26AF2A22F1D8C0EC2843B9FD99872D8A389C0633130BC0165E146F9E6775411E4D9F0F47E26E13581D6C3F199DB0BAAA78BB64C1634B55511F235983FED9C72BB0A907C90C1CB7E376CDE7EE7B6662E77E06C5F457788DE5A24047AE74592BDECC8C091E34CBC29606BB44E46328EE4C0A8F2BBE2A4E0D40FFD91280EE63910A103D7CF27BCCE8D208AC7F5804C9427F930052F060078FEAFFF2FE999C3B244FC6632FF9B8D542392985F08318201ED308201E902010130643056310D300B060355040313044A757374310D300B060355040A13046E6F6E65310B3009060355040B13024D65311C301A06092A864886F70D010901160D6E6F6E65406E6F6E652E636F6D310B3009060355040613025553020AC140FE68A2A6FDC6820A300D06096086480165030402010500A05C300F06092A864886F72F01010831023000301806092A864886F70D010903310B06092A864886F70D010701302F06092A864886F70D0109043122042057F41CB1F9A3A4A8CF0E5DB445FF0A8F60EBBADAEF2A338A16957F040E6393B8300D06092A864886F70D01010B0500048201005C3985CE74549FCF23195CA8FBAA0014DB6CF5A282C8D48E1C782F182C1C1A7139DD6F3EFCD86EF86AC0E9903C7940DB985BD7408317930D29EF48267678973EBA1E333DA5883C548BCA74D3C76022AA5C542C11675236293BB4882B5BF89D92C72E01897C435DC835F99A920305497BA203B1BD70AC80D57DE79C230C0067951D154392FE94883A9257C52420934CEE1FC467590DCB6EA8912E0BBEE295117597144F17A0C6CB51A9CFACD62CD5E1AC9E8D0542E80C849AADDDD390C4D9257A8AB73AF32E6F0989B6A1ABA7BD49DE319E888DBFD967139DA579A6C53CF550F0D37A2463DF95F4125614B6C2ADB06798421274AE76D4BAA55DA2BEAD60DC090F000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")
	v := pdf.Dict(map[string]pdf.Object{
		"ByteRange":   br,
		"ContactInfo": pdf.StringLiteral(""),
		"Contents":    pdf.NewHexLiteral(pkcs7),
		"Filter":      pdf.Name("Adobe.PPKLite"),
		"Location":    pdf.StringLiteral(""),
		"M":           pdf.StringLiteral(pdf.DateString(time.Now())),
		"Name":        pdf.StringLiteral("Mr Signer"),
		"Reason":      pdf.StringLiteral(""),
		"SubFilter":   pdf.Name("adbe.pkcs7.detached"),
		"Type":        pdf.Name("Sig"),
	})

	vid, err := c.XRefTable.IndRefForNewObject(v)
	if err != nil {
		return err
	}
	formFields, _ := createAnnotation(c.XRefTable, *vid)
	acroform := pdf.Dict(map[string]pdf.Object{
		"SigFlags": pdf.Integer(3),
		"Fields":   pdf.Array{*formFields},
	})
	fid, err := c.XRefTable.IndRefForNewObject(acroform)
	if err != nil {
		return err
	}
	c.RootDict.Insert("AcroForm", *fid)

	pg, _ := c.DereferenceDictEntry(c.RootDict, "Pages")
	pgd := pg.(pdf.Dict)
	kids := pgd.ArrayEntry("Kids")
	p0, _ := c.DereferenceDict(kids[0])

	annots := pdf.Array{*formFields}
	anin, _ := c.XRefTable.IndRefForNewObject(annots)
	p0.Update("Annots", *anin)

	buf1 := bytes.NewBuffer(nil)
	pdfsign.WriteOutPdf(c, buf1)
	x1 := buf1.Bytes()
	ioutil.WriteFile("f1.pdf", x1, 0644)

	r := pdfsign.GetHashRanges(c, &v)
	h := sha256.New()
	for _, hr := range r {
		h.Write(hr)
	}
	k := h.Sum(nil)

	//fmt.Println(hex.EncodeToString(k))
	signature := pdfsign.Sign(k)
	fmt.Println(hex.EncodeToString(signature))

	c2, err := pdfcpu.ReadContextFile("f1.pdf")
	if err != nil {
		panic(err)
	}
	fmt.Println(c2)

	return nil
}

type DummySigner struct {
	pdf.Signer
}

func (d DummySigner) EstimateSignatureLength() int {
	return 100
}

func (d DummySigner) Sign(r io.Reader) ([]byte, error) {
	h := sha256.New()
	_, err := io.Copy(h, r)
	if err != nil {
		return nil, err
	}
	fmt.Println(hex.EncodeToString(h.Sum(nil)))
	return []byte{1, 2, 3, 4, 5}, nil
}

type Pkcs7Signer struct {
	pdf.Signer
}

func (s Pkcs7Signer) EstimateSignatureLength() int {
	return 10000
}

func (s Pkcs7Signer) Sign(r io.Reader) ([]byte, error) {
	b, err := ioutil.ReadAll(r)
	if err != nil {
		return nil, err
	}
	return pdfsign.Sign(b), nil
}

type TsaSigner struct {
	pdf.Signer
	Url string
}

func (s TsaSigner) EstimateSignatureLength() int {
	return 10000
}

func (s TsaSigner) Sign(r io.Reader) ([]byte, error) {
	b, err := ioutil.ReadAll(r)
	if err != nil {
		return nil, err
	}
	h := sha256.New()
	h.Write(b)
	digest := h.Sum(nil)
	tsa := rfc3161.NewClient(s.Url)
	tsq, err := rfc3161.NewTimeStampReq(crypto.SHA256, digest[:])
	tsq.CertReq = true
	if err != nil {
		return nil, err
	}
	//fmt.Println(tsq)
	//fmt.Println(tsa)
	tsr, err := tsa.Do(tsq)
	if err != nil {
		return nil, err
	}
	// Marshal the Signed Attributes
	sig, err := asn1.Marshal(tsr.TimeStampToken)
	if err != nil {
		return nil, err
	}
	fmt.Println(tsr.Status)
	fmt.Println(tsr.TimeStampToken)
	fmt.Println(hex.EncodeToString(sig))
	return sig, nil
}

func Two() error {
	// Create a signed version of inFile.

	if len(os.Args) != 3 {
		panic("usage: xxx test.pdf out.pdf")
	}
	inFile := os.Args[1]
	outFile := os.Args[2]
	fmt.Println(inFile, outFile)
	//signer := Pkcs7Signer{}
	signer := TsaSigner{Url: "https://freetsa.org/tsr"}
	err := pdfcpu.TimestampFile(inFile, outFile, nil, signer)
	if err == pdf.ErrHasAcroForm {
		log.Println("already has an AcroForm")
		return err
	}
	return err
}

func main() {
	PDFCPULog.SetDefaultCLILogger()
	//PDFCPULog.SetDefaultTraceLogger()
	//PDFCPULog.SetDefaultParseLogger()
	//PDFCPULog.SetDefaultReadLogger()
	PDFCPULog.SetDefaultValidateLogger()
	PDFCPULog.SetDefaultOptimizeLogger()
	//PDFCPULog.SetDefaultWriteLogger()

	//err := doSign()
	err := Two()
	if err != nil {
		panic(err)
	}
}
